<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Ubuntu 18.04 开机启动]]></title>
    <url>%2F2019%2F05%2F16%2FUbuntu-18-04-%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[Ubuntu 18.04 开机启动Ubuntu 18.04更改了系统初始化程序，在之前用的是==init==，现在用的是==systemd==。 所以现在配置开启启动脚本，不再是配置==/etc/rc.local==，而是在配置systemd的配置文件。 配置systemd启动systemd默认读取/etc/systemd/system下的配置文件。一般系统安装完/lib/systemd/system/下会有rc-local.service文件，复制过来用即可，由于我之前已经配置好了，就直接给出该文件。 1234567891011121314151617cd /etc/systemd/system/vi rc-local.service[Unit]Description=/etc/rc.local CompatibilityConditionPathExists=/etc/rc.local[Service]Type=forkingExecStart=/etc/rc.local startTimeoutSec=0StandardOutput=ttyRemainAfterExit=yesSysVStartPriority=99[Install]WantedBy=multi-user.target 配置启动脚本此时已经配置了 ==/etc/rc.local== 为启动脚本。但是我们还未创建==/etc/rc.local==，故创建并且编辑该文件。 123456#!/bin/sh -edate &gt;&gt; /root/start.logexit 0 由于该文件为系统文件，为了避免经常改动系统文件。故利用该文件，再引导启动一个用户文件，即 ==/root/bin/rc-vae.sh==。 测试重启服务器，查看是否有 ==/root/start.log==文件生成。如果有文件生成，即配置成功。 创建用户启动文件为了避免每次修改启动文件，都去更改系统目录下的文件，故修改==rc.local==文件为如下内容，即创建一个用户的启动文件，并且有==rc.local==引导。 12345#!/bin/sh -e/root/bin/rc-vae.sh &amp; exit 0 注意相关的文件不要忘了加上==可执行==权限。]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python中XML的读写总结]]></title>
    <url>%2F2018%2F08%2F17%2FPython%E4%B8%ADXML%E7%9A%84%E8%AF%BB%E5%86%99%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[基于DOM导入： import xml.dom.minidom as minidom 写入创建文档：dom = minidom.getDOMImplementation().createDocument(None,&#39;Root&#39;,None)获得根节点：root = dom.documentElement创建节点：element = dom.createElement(&#39;Name&#39;)给这个节点添加文本：element.appendChild(dom.createTextNode(&#39;default&#39;))注意：这里的节点文本值是存成另外一个节点的，是createTextNode设置属性：element.setAttribute(&#39;age&#39;, &#39;20&#39;)添加到节点：root.appendChild(element)完整代码：1234567891011121314151617181920212223# -*- coding:utf-8 -*-import xml.dom.minidom as minidomdom = minidom.getDOMImplementation().createDocument(None,'Root',None)root = dom.documentElementfor i in range(5): element = dom.createElement('Name') element.appendChild(dom.createTextNode('default')) element.setAttribute('age', str(i)) root.appendChild(element)# 保存文件with open('default.xml', 'w', encoding='utf-8') as f: dom.writexml(f, addindent='\t', newl='\n',encoding='utf-8')# 文档内容&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;Root&gt; &lt;Name age="0"&gt;default&lt;/Name&gt; &lt;Name age="1"&gt;default&lt;/Name&gt; &lt;Name age="2"&gt;default&lt;/Name&gt; &lt;Name age="3"&gt;default&lt;/Name&gt; &lt;Name age="4"&gt;default&lt;/Name&gt;&lt;/Root&gt; 读取读取文档：dom = minidom.parse(&#39;default.xml&#39;)获得根节点：root = dom.documentElement按照名称查找子节点，注意这里会递归查找所有子节点：names = root.getElementsByTagName(&#39;Name&#39;)所有的子节点：root.childNodes注意：每个节点的文本值存在TextNode节点中，也就是最后一个节点的第一个子节点查看是否含有属性：name.hasAttribute(&#39;age&#39;)查看属性：name.getAttribute(&#39;age&#39;)完整代码：123456789101112131415dom = minidom.parse('default.xml')root = dom.documentElementnames = root.getElementsByTagName('Name')for name in names: # 它的第一个子节点是一个textnode，存取的是真正的节点值 print(name.childNodes[0].nodeValue, end='\t') if name.hasAttribute('age'): print(name.getAttribute('age'), end='\t') print('')# 输出default 0 default 1 default 2 default 3 default 4 基于ElementTree导入：import xml.etree.ElementTree as ET 写入创建节点：root = ET.Element(&#39;Root&#39;)创建文档：tree = ET.ElementTree(root)设置文本值：element.text = &#39;default&#39;设置属性：element.set(&#39;age&#39;, str(i))添加节点：root.append(element)写入文档：tree.write(&#39;default.xml&#39;, encoding=&#39;utf-8&#39;, xml_declaration=True)但这样写入会有个问题，写入的XML会在同一行，缺少换行符，Etree本身并没有提供换行的选项，翻看了国外大神的回答，对root处理以后，再次写入将有换行符。完整代码如下：12345678910111213141516171819202122232425262728293031323334353637383940# -*- coding:utf-8 -*-import xml.etree.ElementTree as ET# 增加换行符def __indent(elem, level=0): i = "\n" + level*"\t" if len(elem): if not elem.text or not elem.text.strip(): elem.text = i + "\t" if not elem.tail or not elem.tail.strip(): elem.tail = i for elem in elem: __indent(elem, level+1) if not elem.tail or not elem.tail.strip(): elem.tail = i else: if level and (not elem.tail or not elem.tail.strip()): elem.tail = iroot = ET.Element('Root') # 创建节点tree = ET.ElementTree(root) # 创建文档for i in range(5): element = ET.Element('Name') element.set('age', str(i)) element.text = 'default' root.append(element)__indent(root) # 增加换行符tree.write('default.xml', encoding='utf-8', xml_declaration=True)# 文档内容&lt;?xml version='1.0' encoding='utf-8'?&gt;&lt;Root&gt; &lt;Name age="0"&gt;default&lt;/Name&gt; &lt;Name age="1"&gt;default&lt;/Name&gt; &lt;Name age="2"&gt;default&lt;/Name&gt; &lt;Name age="3"&gt;default&lt;/Name&gt; &lt;Name age="4"&gt;default&lt;/Name&gt;&lt;/Root&gt; 读取读取文档：tree = ET.parse(&#39;default.xml&#39;)获得根节点：root = tree.getroot()获得所有子节点：list(root)查找子节点，注意这里不会递归查找所有子节点：root.findall(&#39;Name&#39;)查找子节点，递归查找所有子节点：root.iter(&#39;Name&#39;)查看节点名称：root.tag全部代码：1234567891011121314151617181920212223# -*- coding:utf-8 -*-import xml.etree.ElementTree as ETtree = ET.parse('default.xml')root = tree.getroot()for node in list(root): print(node.text, node.tag, node.get('age'))for node in root.findall('Name'): print(node.text, node.tag, node.get('age'))# 输出default Name 0default Name 1default Name 2default Name 3default Name 4default Name 0default Name 1default Name 2default Name 3default Name 4]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Event事件机制]]></title>
    <url>%2F2018%2F07%2F11%2FEvent%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[1.事件类123456789101112131415161718192021222324252627282930313233343536373839404142434445QAbstractEventDispatcher //Interface to manage Qt's event queueQBasicTimer //Timer events for objectsQChildEvent //Contains event parameters for child object eventsQDynamicPropertyChangeEvent //Contains event parameters for dynamic property change eventsQEvent //The base class of all event classes. Event objects contain event parametersQTimerEvent //Contains parameters that describe a timer eventQTimer //Repetitive and single-shot timersQActionEvent //Event that is generated when a QAction is added, removed, or changedQCloseEvent //Contains parameters that describe a close eventQContextMenuEvent //Contains parameters that describe a context menu eventQDragEnterEvent //Event which is sent to a widget when a drag and drop action enters itQDragLeaveEvent //Event that is sent to a widget when a drag and drop action leaves itQDragMoveEvent //Event which is sent while a drag and drop action is in progressQDropEvent //Event which is sent when a drag and drop action is completedQEnterEvent //Contains parameters that describe an enter eventQExposeEvent //Contains event parameters for expose eventsQFileOpenEvent //Event that will be sent when there is a request to open a file or a URLQFocusEvent //Contains event parameters for widget focus eventsQHelpEvent //Event that is used to request helpful information about a particular point in a widgetQHideEvent //Event which is sent after a widget is hiddenQHoverEvent //Contains parameters that describe a mouse eventQIconDragEvent //Indicates that a main icon drag has begunQInputEvent //The base class for events that describe user inputQInputMethodEvent //Parameters for input method eventsQKeyEvent //Describes a key eventQMouseEvent //Contains parameters that describe a mouse eventQMoveEvent //Contains event parameters for move eventsQNativeGestureEvent //Contains parameters that describe a gesture eventQPaintEvent //Contains event parameters for paint eventsQPlatformSurfaceEvent //Used to notify about native platform surface eventsQPointingDeviceUniqueId //Identifies a unique object, such as a tagged token or stylus, which is used with a pointing deviceQResizeEvent //Contains event parameters for resize eventsQScrollEvent //Sent when scrollingQScrollPrepareEvent //Sent in preparation of scrollingQShortcutEvent //Event which is generated when the user presses a key combinationQShowEvent //Event that is sent when a widget is shownQStatusTipEvent //Event that is used to show messages in a status barQTabletEvent //Contains parameters that describe a Tablet eventQTouchEvent //Contains parameters that describe a touch eventQWhatsThisClickedEvent //Event that can be used to handle hyperlinks in a "What's This?" textQWheelEvent //Contains parameters that describe a wheel eventQWindowStateChangeEvent //The window state before a window state changeQGestureEvent //The description of triggered gesturesQShortcut //Used to create keyboard shortcuts 2.事件函数今天要说的是event()函数。记得之前曾经提到过这个函数，说在事件对象创建完毕后，Qt将这个事件对象传递给QObject的event()函数。event()函数并不直接处理事件，而是将这些事件对象按照它们不同的类型，分发给不同的事件处理器(event handler)。 event()函数主要用于事件的分发，所以，如果你希望在事件分发之前做一些操作，那么，就需要注意这个event()函数了。为了达到这种目的，我们可以重写event()函数。例如，如果你希望在窗口中的tab键按下时将焦点移动到下一组件，而不是让具有焦点的组件处理，那么你就可以继承QWidget，并重写它的event()函数，已达到这个目的：123456789bool MyWidget::event(QEvent *event) &#123; if (event-&gt;type() == QEvent::KeyPress) &#123; QKeyEvent *keyEvent = static_cast&lt;QKeyEvent *&gt;(event); if (keyEvent-&gt;key() == Qt::Key_Tab) &#123; // 处理Tab鍵 return true; &#125; &#125; return QWidget::event(event); 3.事件过滤机制Qt创建了QEvent事件对象之后，会调用QObject的event()函数做事件的分发。有时候，你可能需要在调用event()函数之前做一些另外的操作，比如，对话框上某些组件可能并不需要响应回车按下的事件，此时，你就需要重新定义组件的event()函数。如果组件很多，就需要重写很多次event()函数，这显然没有效率。为此，你可以使用一个事件过滤器，来判断是否需要调用event()函数。 QOjbect有一个eventFilter()函数，用于建立事件过滤器。这个函数的签名如下：1virtual bool QObject::eventFilter(QObject *obj, QEvent *event); 如果obj对象安装了事件过滤器，这个函数会被调用并进行事件过滤，然后才轮到组件进行事件处理。在重写这个函数时，如果你需要过滤掉某个事件，例如停止对这个事件的响应，需要返回true。 上面的例子中为MainWindow建立了一个事件过滤器。为了过滤某个组件上的事件，首先需要判断这个对象是哪个组件，然后判断这个事件的类型。例如，我不想让textEdit组件处理键盘事件，于是就首先找到这个组件，如果这个事件是键盘事件，则直接返回true，也就是过滤掉了这个事件，其他事件还是要继续处理，所以返回false。对于其他组件，我们并不保证是不是还有过滤器，于是最保险的办法是调用父类的函数。 在创建了过滤器之后，下面要做的是安装这个过滤器。安装过滤器需要调用installEventFilter()函数。这个函数的签名如下：1void QObject::installEventFilter(QObject *obj); 这个函数是QObject的一个函数，因此可以安装到任何QObject的子类，并不仅仅是UI组件。这个函数接收一个QObject对象，调用了这个函数安装事件过滤器的组件会调用filterObj定义的eventFilter()函数。例如，textField.installEventFilter(obj)，则如果有事件发送到textField组件是，会先调用obj-&gt;eventFilter()函数，然后才会调用textField.event()。 当然，你也可以把事件过滤器安装到QApplication上面，这样就可以过滤所有的事件，已获得更大的控制权。不过，这样做的后果就是会降低事件分发的效率。 如果一个组件安装了多个过滤器，则最后一个安装的会最先调用，类似于堆栈的行为。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PyQt5中异步刷新UI和Python中的多线程总结]]></title>
    <url>%2F2018%2F07%2F06%2FPyQt5%E4%B8%AD%E5%BC%82%E6%AD%A5%E5%88%B7%E6%96%B0UI%E5%92%8CPython%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[PyQtPyQt简介PyQt是Qt的python接口，PyQt的文档较少，但接口和函数可以完全参照Qt，继承了Qt中大量的控件以及信号机制，十分方便。以下简介一个基本的PyQt程序。 需要导入的类主要来自三个包 from PyQt5.QtWidgets import 常用的控件 PyQt5.QtCore 核心功能类，如QT，QThread，pyqtSignal PyQt5.QtGui UI类，如QFont 基础的程序结构：12345678910111213141516class Example(QWidget): def __init__(self): super()__init__() self.setupUI() def setupUI(): self.show() pass # 设置UIif __name__ == '__main__': app = QApplication(sys.argv) # 启动app ex = Example() # 实例化一个自己派生的 # 也可以实例化库中的控件 # q = QPushButton() # q.show() sys.exit(app.exec_()) 总体来说： 首先实例化APP 实例化预定义控件或者自己派生自库中的控件，记得调用show()函数 执行并安全退出 Python中的多线程python中的多线程使用较为方便，主要使用threading.Thread类： 线程启动使用start()函数 如果需要等待线程执行使用join，这样主线程会阻塞实现方式一 直接传入函数，启动线程，可以传入参数12345678910import time, threadingdef threadFunction(): while True: print(11111) time.sleep()# 用于命名，可以通过threading.current_thread().name获得t = threading.Thread(target=threadFunction, name='funciton')# 如果线程有参数t = threading.Thread(target=threadFunction, args=(), name='funciton')t.start() 实现方式二继承Thread，重写run方法1234567891011121314151617from threading import Threadimport timeclass Example(Thread): def __init__(self): super().__init__() def run(self): while True: time.sleep(1) print(11111111)if __name__ == '__main__': a = Example() a.start() a.join() print(222222222) 注意：1. 使用join方法会让主线程阻塞在这里，等待子线程结束，在里面可以设置阻塞的时间 a.setDaemon(True)在start前设置，可以保证在主线程终止时，子线程也终止 信号机制QT中的信号机制能够方便的编写回调。1. 很多控件都有预定的信号如clicked，直接使用clicked.connect连接槽函数即可。2. 继承自Qt的类，然后自定义一个signal类变量，在实例连接信号就可以了12345678910111213class Example(QWidget): signal = pyqtSignal() # 括号里填写信号传递的参数 # 发射信号 def func(self): self.signal.emit()# 使用信号a = Example()a.signal.connect(callback)# 槽函数def callback(): pass UI刷新在界面中，通常用会有一些按钮，点击后触发事件，比如去下载一个文件或者做一些操作，这些操作会耗时，如果不能及时结束，主线程将会阻塞，这样界面就会出现未响应的状态，因此必须使用多线程来解决这个问题。注意： PyQt5不能在子线程中刷新线程，这样会造成界面卡死，因此不能使用常规的多线程刷新UI。 但是又必须要实现子线程和主线程之间的通信，否则无法得知任务是否完成。因此使用PyQt5中的QThread，这样既可以使用信号机制，又能够使用多线程。 当启动多线程后，注册信号，槽函数为主线程中的函数，当任务完成后，发射信号，在主线程中对UI进行更新。 注：由于需要注册信号，thread需要是继承自QThread的类12345678910111213141516171819202122232425class Example(QThread): signal = pyqtSignal() # 括号里填写信号传递的参数 def __init__(self): super().__init__() def __del__(self): self.wait() def run(self): # 进行任务操作 self.signal.emit() # 发射信号# UI类中def buttonClick(self) self.thread = Example() self.thread.signal.connect(self.callback) self.thread.start() # 启动线程def callbakc(self): pass--------------------- 作者：新安浅滩 来源：CSDN 原文：https://blog.csdn.net/hu694028833/article/details/80977302 版权声明：本文为博主原创文章，转载请附上博文链接！]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Qt</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式整理]]></title>
    <url>%2F2018%2F04%2F08%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[1. 常用正则表达式 表达式 说明 \r, \n 代表回车和换行符 \t 制表符 \ 代表 “\” 本身 \^ 匹配 ^ 符号本身 $ 匹配 $ 符号本身 元字符 说明 . 匹配除了换行符以外的任意字符 \w 匹配字母、数字、下划线、汉字 \s 匹配任意的空白符 \b 单词的开始或结尾 ~ 匹配字符串的开始 $ 匹配字符串的结束 如：\ba\w\b ：匹配以字母a开头的单词——先是某个单词开始处(\b)，然后是字母a,然后是任意数量的字母或数字(\w)，最后是单词结束处(\b)。 \d+ ：匹配1个或更多连续的数字。这里的+是和类似的元字符，不同的是匹配重复任意次(可能是0次)，而+则匹配重复1次或更多次。 \b\w{6}\b： 匹配刚好6个字符的单词。 表达式 说明 [ ] 包含一系列字符 [^ ] 包含之外一系列字符 [ab5@]匹配a” 或 “b” 或 “5” 或 “@ [^abc]： 包含abc之外的任意字符 [f-k]f-k之间的任意字符| 表达式 | 说明 || — | — || {n} | 表达式重复n次，比如：“\w{2}” 相当于 “\w\w”；“a{5}” 相当于 “aaaaa” || {m,n} | 表达式至少重复m次，最多重复n次，比如：“ba{1,3}”可以匹配 “ba”或”baa”或”baaa || {m,} | 表达式至少重复m次，比如：“\w\d{2,}”可以匹配 “a12”,”_456”,”M12344”… || ? | 匹配表达式0次或者1次，相当于 {0,1}，比如：“a[cd]?”可以匹配 “a”,”ac”,”ad” || + | 表达式至少出现1次，相当于 {1,}，比如：“a+b”可以匹配 “ab”,”aab”,”aaab”… || | 表达式不出现或出现任意次，相当于 {0,}，比如：[“\^b”可以匹配 “b”,”^^^b”…](http://www.regexlab.com/zh/workshop.asp?pat=%5C%5E*b&amp;txt=%5E%2Cb%2C%5E%5E%5Eb%2C%5E%5E%5E%5E%5E%5E%5Eb) | 2.Qt 中使用正则表达式​ Qt 用QRegExp 来封装正则表达式。如： QRegExp rx(“^[0-9]+(.\d+)?$”); 例如我们又这个一个有规则的字符串：价格:数量:商家编码:属性名:属性值;属性名:属性值; 价格:数量:商家编码:属性名:属性值;属性名:属性值;属性名:属性值; 价格:数量:商家编码:属性名:属性值; 想要分成： 价格:数量:商家编码:属性名:属性值;属性名:属性值;价格:数量:商家编码:属性名:属性值;属性名:属性值;属性名:属性值;价格:数量:商家编码:属性名:属性值; 首先选择合适的正则表达式：(\w:){3}(\w:\w*;)+， 然后： 12345678QRegExp rx(tr("(\w:)&#123;3&#125;(\w:\w*;)+"));int pos(0);while ((pos = rx.indexIn(str, pos)) != -1)&#123;strList.push_back(rx.capturedTexts().at(0));pos += rx.matchedLength();&#125; 这里 strList 就是想要的结果了。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sqlalchemy automap Demo]]></title>
    <url>%2F2018%2F03%2F06%2FSqlalchemy%20automap%20Demo%2F</url>
    <content type="text"><![CDATA[123from sqlalchemy import create_engine, Table, Column, Integer, String, MetaData, ForeignKeyfrom sqlalchemy.orm import Sessionfrom sqlalchemy.ext.automap import automap_base 123456if __name__ == '__main__': engine_str = "mysql+pymysql://user:password@host:port/employees?charset=utf8mb4" engine = create_engine(engine_str, echo=True) session = Session(engine) Base = automap_base() Base.prepare(engine, reflect=True) 1234# 查询测试result = session.query(Base.classes.user).all()for i in result: print(i.id) 123456789101112# orm 映射User = Base.classes.userCustomers = Base.classes.CustomersOrders = Base.classes.Orders result = session.query(Customers, Orders).filter_by(cust_id=1000000001).first()# print(result)for i in result: if isinstance(i, Customers): print(i.cust_name) if isinstance(i, Orders): print(i.order_date)]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>SQLAlchemy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 线程池/进程池 内存管理]]></title>
    <url>%2F2018%2F03%2F03%2FPython%20%E7%BA%BF%E7%A8%8B%E6%B1%A0%20%E8%BF%9B%E7%A8%8B%E6%B1%A0%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[concurrent.futures 线程池/进程池内存管理起因之前进行爬虫任务的时候遇到了这么一个需求，1G 内存的机器跑爬虫，爬取一个网站的数据，之前使用的是这样一种方式：1234567891011121314151617 futures = list() with ThreadPool(max_workers=20) as exc: for tr in table.select("tr"): # 取线程执行结果 future = exc.submit(self.get_asn, tr.strings) futures.append(future)# 使用 as_completed 异步方式处理完成任务的线程for future in as_completed(futures): result = future.result() # 拼接 asn.json 的 path file_path = result["asn"] + ".json" asn_file = os.path.join(self.base_data_path, file_path) with open(asn_file, "w", encoding="utf8") as f: f.write(json.dumps(result)) 使用了 concurrent.futures 的 ThreadPoolExecutor submit 方法，因为开启了20个线程同时爬取，连接网站的速度还很快，任务很快就被处理完成了，可以看到我时完成一个任务的时候就进行写文件了操作，但是2分钟后很快程序就终止了，监控程序发现时由于程序内存占用达到 80% 被系统 Kill 掉了。 为什么内存会爆呢？监控内存显示，程序处理完任务之后，内存并没有被立刻释放，而是有很长时间延迟之后才被释放（ 在此吐槽 python GC） 改进方法： 参考 https://stackoverflow.com/questions/34770169/using-concurrent-futures-without-running-out-of-ram123456789101112131415161718192021222324252627282930313233# 允许同时进行的工作数MAX_JOBS_IN_QUEUE = 1000tr_list = table.select("tr")tr_left = len(tr_list) - 1 # &lt;----tr_iter = iter(tr_list) # &lt;------jobs = dict() with ThreadPool(max_workers=20) as exc: while tr_left: print("#" * 100, "TASK: &#123;&#125; &lt;===&gt; JOB: &#123;&#125;".format(tr_left, len(jobs))) for tr in tr_iter: # 取线程执行结果 job = exc.submit(self.get_asn, tr.strings) jobs[job] = tr if len(jobs) &gt; MAX_JOBS_IN_QUEUE: break # limit the job submission for now job # 使用 as_completed 异步方式处理任务线程 for job in as_completed(jobs): tr_left -= 1 # one down - many to go... &lt;--- result = job.result() # 从字典中删除结果，因为我们不需要存储它 del jobs[job] # 拼接 asn.json 的 path file_path = result["asn"] + ".json" asn_file = os.path.join(self.base_data_path, file_path) with open(asn_file, "w", encoding="utf8") as f: f.write(json.dumps(result)) break 改进后内存在切换 html 爬取的时候，会偶尔会升高一下，最高 65%，平均在 35% 左右。 ProcessPoolExecutor 进程同理]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Python</tag>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQLAlchemy 插入 性能 速度 比较]]></title>
    <url>%2F2018%2F01%2F27%2FSQLAlchemy%20%E6%8F%92%E5%85%A5%20%E6%80%A7%E8%83%BD%20%E9%80%9F%E5%BA%A6%20%E6%AF%94%E8%BE%83%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133import timeimport sqlite3 from sqlalchemy.ext.declarative import declarative_basefrom sqlalchemy import Column, Integer, String, create_enginefrom sqlalchemy.orm import scoped_session, sessionmaker Base = declarative_base()DBSession = scoped_session(sessionmaker())engine = None class Customer(Base): __tablename__ = "customer" id = Column(Integer, primary_key=True) name = Column(String(255)) def init_sqlalchemy(dbname='sqlite:///sqlalchemy.db'): global engine engine = create_engine(dbname, echo=False) DBSession.remove() DBSession.configure(bind=engine, autoflush=False, expire_on_commit=False) Base.metadata.drop_all(engine) Base.metadata.create_all(engine) def test_sqlalchemy_orm(n=100000): init_sqlalchemy() t0 = time.time() for i in xrange(n): customer = Customer() customer.name = 'NAME ' + str(i) DBSession.add(customer) if i % 1000 == 0: DBSession.flush() DBSession.commit() print( "SQLAlchemy ORM: Total time for " + str(n) + " records " + str(time.time() - t0) + " secs") def test_sqlalchemy_orm_pk_given(n=100000): init_sqlalchemy() t0 = time.time() for i in xrange(n): customer = Customer(id=i+1, name="NAME " + str(i)) DBSession.add(customer) if i % 1000 == 0: DBSession.flush() DBSession.commit() print( "SQLAlchemy ORM pk given: Total time for " + str(n) + " records " + str(time.time() - t0) + " secs") def test_sqlalchemy_orm_bulk_save_objects(n=100000): init_sqlalchemy() t0 = time.time() n1 = n while n1 &gt; 0: n1 = n1 - 10000 DBSession.bulk_save_objects( [ Customer(name="NAME " + str(i)) for i in xrange(min(10000, n1)) ] ) DBSession.commit() print( "SQLAlchemy ORM bulk_save_objects(): Total time for " + str(n) + " records " + str(time.time() - t0) + " secs") def test_sqlalchemy_orm_bulk_insert(n=100000): init_sqlalchemy() t0 = time.time() n1 = n while n1 &gt; 0: n1 = n1 - 10000 DBSession.bulk_insert_mappings( Customer, [ dict(name="NAME " + str(i)) for i in xrange(min(10000, n1)) ] ) DBSession.commit() print( "SQLAlchemy ORM bulk_insert_mappings(): Total time for " + str(n) + " records " + str(time.time() - t0) + " secs") def test_sqlalchemy_core(n=100000): init_sqlalchemy() t0 = time.time() engine.execute( Customer.__table__.insert(), [&#123;"name": 'NAME ' + str(i)&#125; for i in xrange(n)] ) print( "SQLAlchemy Core: Total time for " + str(n) + " records " + str(time.time() - t0) + " secs") def init_sqlite3(dbname): conn = sqlite3.connect(dbname) c = conn.cursor() c.execute("DROP TABLE IF EXISTS customer") c.execute( "CREATE TABLE customer (id INTEGER NOT NULL, " "name VARCHAR(255), PRIMARY KEY(id))") conn.commit() return conn def test_sqlite3(n=100000, dbname='sqlite3.db'): conn = init_sqlite3(dbname) c = conn.cursor() t0 = time.time() for i in xrange(n): row = ('NAME ' + str(i),) c.execute("INSERT INTO customer (name) VALUES (?)", row) conn.commit() print( "sqlite3: Total time for " + str(n) + " records " + str(time.time() - t0) + " sec") if __name__ == '__main__': test_sqlalchemy_orm(100000) test_sqlalchemy_orm_pk_given(100000) test_sqlalchemy_orm_bulk_save_objects(100000) test_sqlalchemy_orm_bulk_insert(100000) test_sqlalchemy_core(100000) test_sqlite3(100000) 上面代码分别使用了orm， orm带主键，orm的bulk_save_objects, orm的bulk_insert_mappings, 非orm形式，原生的dbapi方式；插入10000条记录的结果如下： 123456SQLAlchemy ORM: Total time for 100000 records 7.2070479393 secsSQLAlchemy ORM pk given: Total time for 100000 records 4.28471207619 secsSQLAlchemy ORM bulk_save_objects(): Total time for 100000 records 1.58296084404 secsSQLAlchemy ORM bulk_insert_mappings(): Total time for 100000 records 0.453973054886 secsSQLAlchemy Core: Total time for 100000 records 0.210998058319 secssqlite3: Total time for 100000 records 0.136252880096 sec 注意： 这里只有第一、二种方式可以拿到插入记录的id，其它都不能直接拿到，需要自己再查询一次。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>SQLAlchemy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQLAlchemy 几种查询方式总结]]></title>
    <url>%2F2018%2F01%2F26%2FSQLAlchemy%20%E5%87%A0%E7%A7%8D%E6%9F%A5%E8%AF%A2%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[几种常见sqlalchemy查询：123456789101112131415161718192021222324252627282930313233#简单查询 print(session.query(User).all()) print(session.query(User.name, User.fullname).all()) print(session.query(User, User.name).all()) #带条件查询 print(session.query(User).filter_by(name='user1').all()) print(session.query(User).filter(User.name == "user").all()) print(session.query(User).filter(User.name.like("user%")).all()) #多条件查询 print(session.query(User).filter(and_(User.name.like("user%"), User.fullname.like("first%"))).all()) print(session.query(User).filter(or_(User.name.like("user%"), User.password != None)).all()) #sql过滤 print(session.query(User).filter("id&gt;:id").params(id=1).all()) #关联查询 print(session.query(User, Address).filter(User.id == Address.user_id).all()) print(session.query(User).join(User.addresses).all()) print(session.query(User).outerjoin(User.addresses).all()) #聚合查询 print(session.query(User.name, func.count('*').label("user_count")).group_by(User.name).all()) print(session.query(User.name, func.sum(User.id).label("user_id_sum")).group_by(User.name).all()) #子查询 stmt = session.query(Address.user_id, func.count('*').label("address_count")).group_by(Address.user_id).subquery() print(session.query(User, stmt.c.address_count).outerjoin((stmt, User.id == stmt.c.user_id)).order_by(User.id).all()) #exists print(session.query(User).filter(exists().where(Address.user_id == User.id))) print(session.query(User).filter(User.addresses.any())) 限制返回字段查询123456789101112131415from sqlalchemy import func # count User records, without# using a subquery.session.query(func.count(User.id)) # return count of user "id" grouped# by "name"session.query(func.count(User.id)).\ group_by(User.name) from sqlalchemy import distinct # count distinct "name" valuessession.query(func.count(distinct(User.name))) 记录总数查询：123456789101112131415from sqlalchemy import func # count User records, without# using a subquery.session.query(func.count(User.id)) # return count of user "id" grouped# by "name"session.query(func.count(User.id)).\ group_by(User.name) from sqlalchemy import distinct # count distinct "name" valuessession.query(func.count(distinct(User.name)))]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>SQLAlchemy</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F01%2F03%2Fpython%203%E7%A7%8D%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[第一种 threading.Thread123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import threadingimport requestsfrom bs4 import BeautifulSoupimport reimport timeimport queue course_url = 'xxxxxxxxxxx' pattern = re.compile(r'&lt;a href="(/zuofa/\d+?)" title="(.*?)" class="shipu"&gt;') headers = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.81 Safari/537.36'&#125; # 创建线程类，继承Thread类# class MyThread(threading.Thread):# def __init__(self, func, args):# super(MyThread, self).__init__()# self.func = func# self.args = args## def run(self):# self.func(*self.args) def extra_links(q, f): """ 用于多线程采集 :param q: url 队列 :param f: 写入的目标文件 :return: """ while not q.empty(): try: url = q.get() r = requests.get(url, headers=headers) if r.status_code == 200: soup = BeautifulSoup(r.text, 'lxml') course_list = soup.find(class_='main-left') links = course_list.find_all(class_='item-tt-link') for i in links: href = i.attrs['href'] f.write('http:&#123;&#125; ----&gt;&#123;&#125;\n'.format(href, i.attrs['title'])) q.task_done() except queue.Empty: break def main(): with open('course_link.txt', 'w', encoding='utf8') as f: q = queue.Queue() for i in range(1, 101): q.put('&#123;&#125;?page=&#123;&#125;'.format(course_url, i)) threads = [] for i in range(20): t = threading.Thread(target=extra_links, args=(q, f)) threads.append(t) for i in threads: i.start() for i in threads: i.join() if __name__ == '__main__': s = time.clock() main() print('运行时间: %.2f' % (time.clock() - s)) 第二种 concurrent.futures import ThreadPoolExecutor1234567891011121314151617181920212223242526272829303132333435import requestsfrom concurrent.futures import ThreadPoolExecutorfrom requests.packages.urllib3.exceptions import InsecureRequestWarningimport timeimport refrom bs4 import BeautifulSoup requests.packages.urllib3.disable_warnings(InsecureRequestWarning) course_url = ['xxxxxxxxxxx?page=&#123;&#125;'.format(i) for i in range(1, 101)] pattern = re.compile(r'&lt;a href="(/zuofa/\d+?)" title="(.*?)" class="shipu"&gt;') headers = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.81 Safari/537.36'&#125; def extra_links(url): r = requests.get(url, headers=headers) if r.status_code == 200: soup = BeautifulSoup(r.text, 'lxml') course_list = soup.find(class_='main-left') links = course_list.find_all(class_='item-tt-link') for i in links: href = i.attrs['href'] f.write('http:&#123;&#125; ----&gt;&#123;&#125;\n'.format(href, i.attrs['title'])) if __name__ == '__main__': s = time.clock() with open('course_link.txt', 'w', encoding='utf8') as f: with ThreadPoolExecutor(max_workers=20) as executor: executor.map(extra_links, course_url) print('运行用时: %.2f 秒' % (time.clock() - s)) 第三种 from multiprocessing.dummy import Pool as ThreadPool12345678910111213141516171819202122232425262728293031323334353637from multiprocessing.dummy import Pool as ThreadPoolimport requestsfrom requests.packages.urllib3.exceptions import InsecureRequestWarningimport timeimport refrom bs4 import BeautifulSoup requests.packages.urllib3.disable_warnings(InsecureRequestWarning) course_url = ['xxxxxxxxxxxx?page=&#123;&#125;'.format(i) for i in range(1, 101)] pattern = re.compile(r'&lt;a href="(/zuofa/\d+?)" title="(.*?)" class="shipu"&gt;') headers = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.81 Safari/537.36'&#125; def extra_links(url): r = requests.get(url, headers=headers) if r.status_code == 200: soup = BeautifulSoup(r.text, 'lxml') course_list = soup.find(class_='main-left') links = course_list.find_all(class_='item-tt-link') for i in links: href = i.attrs['href'] f.write('http:&#123;&#125; ----&gt;&#123;&#125;\n'.format(href, i.attrs['title'])) if __name__ == '__main__': s = time.clock() with open('course_link.txt', 'w', encoding='utf8') as f: pool = ThreadPool(20) pool.map(extra_links, course_url) pool.close() pool.join() print('运行用时: %.2f 秒' % (time.clock() - s)) 速度可自行测试 后两种相对简单]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Geopandas 安装 (python中的地理空间数据)]]></title>
    <url>%2F2017%2F12%2F22%2FGeopandas%20%E5%AE%89%E8%A3%85%20(python%E4%B8%AD%E7%9A%84%E5%9C%B0%E7%90%86%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE)%2F</url>
    <content type="text"><![CDATA[Geopandas 依赖库从 http://www.lfd.uci.edu/~gohlke/pythonlibs 下载 Fiona , GDAl , pyproj , Shapely其他包可以通过 pip install geopandas 安装 包 版本 版本 Fiona 1.7.6 1.7.6 GDAL 2.1.3 2.1.3 Shapely 1.5.17 1.5.17 appdirs 1.4.3 1.4.3 better-exceptions 0.1.7 0.1.7 click 6.7 6.7 click-plugins 1.0.3 1.0.3 cligj 0.4.0 0.4.0 colorama 0.3.9 0.3.9 cycler 0.10.0 0.10.0 descartes 1.1.0 1.1.0 geopandas 0.2.1 0.2.1 matplotlib 2.0.1 2.0.1 munch 2.1.1 2.1.1 numpy 1.12.1 1.11.2 packaging 16.8 16.8 pandas 0.19.2 0.19.2 pip 9.0.1 9.0.1 pyparsing 2.2.0 2.2.0 pyproj 1.9.5.1 1.9.5.1 python-dateutil 2.6.0 2.6.0 pytz 2017.2 2016.10 setuptools 35.0.2 35.0.2 six 1.10.0 1.10.0]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>SQLAlchemy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python os.system os.popen 模块 调用命令行]]></title>
    <url>%2F2017%2F12%2F22%2Fpython%20os.system%20os.popen%20%E6%A8%A1%E5%9D%97%20%E8%B0%83%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[123456789import os from pprint import pprint # 只能执行 不能获取返回信息os.system(&apos;dir&apos;)# 可以获取命令行返回信息 tmp = os.popen(&apos;dir &apos;).readlines() pprint(tmp)]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python查看是32位还是64位版本]]></title>
    <url>%2F2017%2F12%2F22%2Fpython%E6%9F%A5%E7%9C%8B%E6%98%AF32%E4%BD%8D%E8%BF%98%E6%98%AF64%E4%BD%8D%E7%89%88%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[12345&gt;&gt;&gt; import platform&gt;&gt;&gt; platform.architecture()('64bit', 'ELF')]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[styleSheet样式无效]]></title>
    <url>%2F2017%2F12%2F16%2FstyleSheet%E6%A0%B7%E5%BC%8F%E6%97%A0%E6%95%88%2F</url>
    <content type="text"><![CDATA[CSubWidget 设置的窗体样式是无效的，查看文档会发现 QWidgetSupports only the background, background-clip and background-origin properties.If you subclass from QWidget, you need to provide a paintEvent for your custom QWidget as below:void CustomWidget::paintEvent(QPaintEvent *){ QStyleOption opt; opt.init(this); QPainter p(this); style()-&gt;drawPrimitive(QStyle::PE_Widget, &amp;opt, &amp;p, this);}The above code is a no-operation if there is no stylesheet set.Warning: Make sure you define the Q_OBJECT macro for your custom widget. 为CSubWidget 加上paintEvent就可以解决]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QT控件及示例]]></title>
    <url>%2F2017%2F12%2F07%2FQT%E6%8E%A7%E4%BB%B6%E5%8F%8A%E7%A4%BA%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[QT控件及示例QT属性控件项目https://github.com/lexxmark/QtnProperty 比特币交易软件https://github.com/JulyIGHOR/QtBitcoinTrader 导航控件http://qt-apps.org/content/show.php/NavBar?content=162885 虚拟键盘http://qt-apps.org/content/show.php/VirtualKeyboard?content=107388 扩展控件http://qt-apps.org/content/show.php/ExpanderWidget?content=163843 导航条(类似tab)http://qt-apps.org/content/show.php/DMSNavigation?content=163730 类似Xp左侧的扩展组工具http://qt-apps.org/content/show.php/iisTaskPanel?content=79286 仪表控件http://qt-apps.org/content/show.php/AnalogWidgets?content=87780 遮罩控件http://qt-apps.org/content/show.php/QLightBoxWidget?content=162277 又一个简单的属性控件http://qt-apps.org/content/show.php/Simple+Object+Inspector?content=162244 按钮样式设计器http://qt-apps.org/content/show.php/Button+Styler?content=162217 密集网格控件http://qt-apps.org/content/show.php/GridView?content=158138 全屏适配器http://qt-apps.org/content/show.php/QFullScreenAdapter?content=153900 多选下拉列表http://qt-apps.org/content/show.php/QMultiComboBox?content=149416 数字键盘http://qt-apps.org/content/show.php/NUMPAD?content=155032 table表头控件http://qt-apps.org/content/show.php/QSpreadsheetHeaderView?content=154405 指令应答控件(类似控制台)http://qt-apps.org/content/show.php/ReplWidget?content=152031 十六进制控件未下载成功http://qt-apps.org/content/show.php/QHexEdit?content=133189https://code.google.com/p/qhexedit2/source/checkout 侧边控件(类安卓)http://qt-apps.org/content/show.php/Sidebar+?content=147860 多表头控件http://qt-apps.org/content/show.php/HierarchicalHeaderView?content=103154 仪表控件http://qt-apps.org/content/show.php/QNeedleIndicator?content=118474 有很多控件的集合http://qt-apps.org/content/show.php/wwWidgets?content=126142 图标动态变大小的工具条coolhttp://qt-apps.org/content/show.php/QIrDock?content=115318 属性控件http://qt-apps.org/content/show.php/yape+%28Yet+another+property+editor%29?content=100064 很牛的Grid，带树，带分隔http://qt-apps.org/content/show.php/QExtendedWidgets?content=103163 像wpf的照片墙(无法下载)http://qt-apps.org/content/show.php/THCoverFlow?content=102200 液晶板控件(较粗)http://qt-apps.org/content/show.php/QLedMatrix?content=101193 属性控件http://qt-apps.org/content/show.php/Value+Browser?content=50717 数据列表控件（可打印）http://qt-apps.org/content/show.php/Thetyss+Data+Browser?content=76696 MacNavBarhttp://qt-apps.org/content/show.php/QfMacNavBar?content=78749 倒影控件http://qt-apps.org/content/show.php/QReflex?content=75962 音量控件http://qt-apps.org/content/show.php/QVUMeter?content=75678 照片墙控件像wpfhttp://qt-apps.org/content/show.php/PictureFlow?content=75348 液晶板控件(细)http://qt-apps.org/content/show.php/QSlide?content=75303 下拉按钮http://qt-apps.org/content/show.php/EnumComboBox?content=166012 加速器(悬浮按钮)http://qt-apps.org/content/show.php/modern+computer+flatboat?content=156221]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QTableWidget与QTableView的区别]]></title>
    <url>%2F2017%2F12%2F01%2FQTableWidget%E4%B8%8EQTableView%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[QTableWidget与QTableView的区别QTableWidget继承自QTableView。QSqlTableModel能与QTableView绑定，但不能于QTableWidget绑定。 1234567891011QSqlTableModel *model = new QSqlTableModel; model-&gt;setTable("employee"); model-&gt;setEditStrategy(QSqlTableModel::OnManualSubmit); model-&gt;select(); model-&gt;removeColumn(0); // don't show the ID model-&gt;setHeaderData(0, Qt::Horizontal, tr("Name")); model-&gt;setHeaderData(1, Qt::Horizontal, tr("Salary")); QTableView *view = new QTableView; view-&gt;setModel(model); view-&gt;show(); QTableWidget是QT程序中常用的显示数据表格的空间，很类似于VC、C#中的DataGrid。说到QTableWidget，就必须讲一下它跟QTabelView的区别了。 ​ QTableWidget是QTableView的子类，主要的区别是QTableView可以使用自定义的数据模型来显示内容(也就是先要通过setModel来绑定数据源)，而QTableWidget则只能使用标准的数据模型，并且其单元格数据是QTableWidgetItem的对象来实现的(也就是不需要数据源，将逐个单元格内的信息填好即可)。这主要体现在QTableView类中有setModel成员函数，而到了QTableWidget类中，该成员函数变成了私有。使用QTableWidget就离不开QTableWidgetItem。QTableWidgetItem用来表示表格中的一个单元格，正个表格都需要用逐个单元格构建起来。 ​ 具体区别表格| 区别点 | QTableView | QTableWidget || — | — | — || 继承关系 | | QTableWidget继承自QTableView || 使用数据模型setModel | 可以使用setModel设置数据模型 | setModel是私有函数，不难使用该函数设置数据模型 || 显示复选框setCheckState | 没有函数实现复选框 | QTableWidgetItem类中的setCheckState(Qt::Checked);可以设置复选框 || 与QSqlTableModel绑定 | QTableView能与QSqlTableModel绑定 | QtableWidget不能与QSqlTableModel绑定 | View与Model绑定注意事项 但视图与模型绑定时，模型必须使用new来创建。否则视图不能随着模型的改变而改变。 Eorror错误的写法123456789101112131415QStandardItemModel model(4,2); model.setHeaderData(0, Qt::Horizontal, tr("Label")); model.setHeaderData(1, Qt::Horizontal, tr("Quantity")); ui.tableView-&gt;setModel(&amp;model); for (int row = 0; row &lt; 4; ++row) &#123; for (int column = 0; column &lt; 2; ++column) &#123; QModelIndex index = model.index(row, column, QModelIndex()); model.setData(index, QVariant((row+1) * (column+1))); &#125; &#125; Right 正确的写法1234567891011121314QStandardItemModel *model; model = new QStandardItemModel(4,2); ui.tableView-&gt;setModel(model); model-&gt;setHeaderData(0, Qt::Horizontal, tr("Label")); model-&gt;setHeaderData(1, Qt::Horizontal, tr("Quantity")); for (int row = 0; row &lt; 4; ++row) &#123; for (int column = 0; column &lt; 2; ++column) &#123; QModelIndex index = model-&gt;index(row, column, QModelIndex()); model-&gt;setData(index, QVariant((row+1) * (column+1))); &#125; &#125;]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QMediaPlayer多媒体类]]></title>
    <url>%2F2017%2F11%2F20%2FQMediaPlayer%E5%A4%9A%E5%AA%92%E4%BD%93%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[1.多媒体播放QMediaPlayer类是QT自带的多媒体类。 实现简单的音视频播放是很简单的。12345QMediaPlayer qtaudioPlayer;​qtaudioPlayer-&gt;setMedia(QUrl::fromLocalFile(filePath));​qtaudioPlayer-&gt;play(); 这里的filePath如果是音频路径，就直接播放音频， 如果是视频路径就直接播放视频。 如果是服务上的音视频路径的话， 需要在前面加上一个http://头， 当然如果返回就自带http://头就不用加。 如：服务器返回一个www.test.com/test.wav123filePath = QLatin1String(http://www.test.com/test.wav);​qtaudioPlayer-&gt;setMedia(QUrl::fromLocalFile(filePath)); 这样就可以直接播放网络上的音视频文件了。 2.多媒体控制当然简单的音视频播放是很容易，在实际的播放器制作过程中，需要控制播放过程中的很多操作，QMediaPlayer 提供了很多信号，来让用户处理。 如：1mediaStatusChanged(QMediaPlayer::MediaStatus) 这个是音视频状态改变的信号， 如：暂停， 停止， 播放，它都能直接监控1durationChanged(qint64) 这个是播放文件数据总大小的信号， 它可以获得文件时间长度。1positionChanged(qint64) 这个是播放到什么位置的信号， 参数是以毫秒来计算的。1volumeChanged(int) 这个是声音调节的信号，监控当前声音的大小1mutedChanged(bool) 这个是是否为静音的信号。 ==音视频播放的过程中， 位置和总大小都是用毫秒表示的，可以进行单位换算==。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QLineEdit的setInputMask和正则表达式冲突]]></title>
    <url>%2F2017%2F11%2F16%2FQLineEdit%E7%9A%84setInputMask%E5%92%8C%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%86%B2%E7%AA%81%2F</url>
    <content type="text"><![CDATA[疑问：我想做个IP控件，看到很多个，感觉都不是很理想。就想用下面的形式来做：12345QRegExp regExp(&quot;^(\d&#123;1,2&#125;|1\d\d|2[0-4]\d|25[0-5])...$&quot;); ​ipEdit-&gt;setValidator(new QRegExpValidator(regExp, this));​ipEdit-&gt;setInputMask(&quot;000.000.000.000&quot;); 可是这样发现，当设置setInputMask后，前面的正则表达式就不起作用了，请问下这个是怎样回事，是不是setInputMask本身就是一个正则表达式，这样就把之前的给覆盖了. 2.解决方案123ipEdit-&gt;setInputMask(&quot;000.000.000.000&quot;);​改成 ipEdit-&gt;setInputMask(&quot;000.000.000.000;0&quot;); 就会同时生效 “;0”表示删除时默认填充为0 不想填充为0 可改为“; ”]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IP地址的正则表达式写法]]></title>
    <url>%2F2017%2F11%2F15%2FIP%E5%9C%B0%E5%9D%80%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%86%99%E6%B3%95%2F</url>
    <content type="text"><![CDATA[这里所描述的的是IPv4的地址格式，总长度 32位=4段*8位，每段之间用.分割， 每段都是0-255之间的十进制数值。 将0-255用正则表达式表示，可以分成一下几块来分别考虑： 取值区间 特点 正则写法 可合并的写法 可合并的写法 可合并的写法 0-9 一位数，只有个位，取值是0~9 \d [1-9]?\d (1\d{2}) ([1-9]?\d) (25[0-5] 2[0-4]\d ((1\d{2}) ([1-9]?\d)) 10-99 两位数，十位取值1-9，个位取值是0~9 [1-9]\d 100-199 三位数，最高位取值为1，十位取值0-9，个位取值0-9 1\d{2} - 200-249 三位数，最高位取值为2，十位取值0-4，个位取值0-9 2[0-4]\d - - 250-255 三位数，最高位取值为2，十位取值5，个位取值0-5 25[0-5] - - IP地址格式可表示为：XXX.XXX.XXX.XXX，XXX取值范围是0-255，前三段加一个.重复了三次，在与最后一段合并及组成IP地址的完整格式。 所以IP地址的正则表示法如下：((25[0-5]|2[0-4]\d|((1\d{2})|([1-9]?\d)))\.){3}(25[0-5]|2[0-4]\d|((1\d{2})|([1-9]?\d))) Qt中的正则表达式与C++中的有点区别：”\d”表示”\d”（双斜杠表示单斜杠）]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL主从同步的原理]]></title>
    <url>%2F2017%2F11%2F15%2FMySQL%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E7%9A%84%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[主从同步的原理：1、主库上面有一个IO线程，从库上有一个IO线程和一个SQL线程，从库中的IO线程负责从主库读取binlog，并写入从库的中继日志；SQL线程负责读取并执行中继日志中的binlog，转换sql语句后应用数据库汇总2、通信是： 从库的IO线程给主库发送同步请求，请求中包含用户名密码和binlog的文件名，pos点 主库验证成功后，发送从库需要的binlog日志文件，和binlog文件中pos点 从库的IO线程接收后，把binlog文件转存到中继日志的relay-log文件，并把binlog文件名和pos点记录到master.info文件中，方便下次通信使用 从库的SQl线程监测出relay-log文件后，把relay-log文件转换为binlog文件在本地执行，并把relay-log文件名和pos点记录到relay-log.info文件中 从库再次发送下一轮的请求~~~ 如果slave后面还挂有从库则也要开启binlog，并添加一个参数log-slave-updates]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pro-C/C++编译找不到 stddef.h 文件的解决办法]]></title>
    <url>%2F2017%2F11%2F06%2FPro-C%20C%2B%2B%E7%BC%96%E8%AF%91%E6%89%BE%E4%B8%8D%E5%88%B0%20stddef.h%20%E6%96%87%E4%BB%B6%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[以编译一个 sample 为例，出现找不到 “stddef.h” 文件的错误，如下： 123456789101112131415161718192021$ proc sample.pcPro*C/C++: Release 11.2.0.1.0 - Production on Wed Dec 26 00:40:15 2012Copyright (c) 1982, 2009, Oracle and/or its affiliates. All rights reserved.System default option values taken from: /usr/local/oracle/product/11.2.0/dbhome_1/precomp/admin/pcscfg.cfgError at line 33, column 10 in file /usr/include/stdlib.h#include &lt;stddef.h&gt;.........1PCC-S-02015, unable to open include fileError at line 147, column 10 in file /usr/include/sys/types.h#include &lt;stddef.h&gt;.........1PCC-S-02015, unable to open include fileError at line 25, column 10 in file /usr/include/alloca.h#include &lt;stddef.h&gt;.........1........... 解决办法： 先确定 stddef.h 在gcc的哪个目录下 12find /usr -name stddef.h /usr/lib/gcc/x86_64-redhat-linux/4.4.4/include/stddef.h 在 $ORACLE_HOME/precomp/admin/pcscfg.cfg 文件中加入这个目录 1/usr/lib/gcc/x86_64-redhat-linux/4.4.4/include/ 然后再编译：$ proc sample.pc 生成对应的 sample.c 文件，问题解决。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用Sphinx创建Python文档]]></title>
    <url>%2F2017%2F11%2F06%2F%E5%88%A9%E7%94%A8Sphinx%E5%88%9B%E5%BB%BAPython%E6%96%87%E6%A1%A3%2F</url>
    <content type="text"><![CDATA[程序猿最喜欢的就是写代码，最不喜欢的莫过于写文档。项目刚开始的时候，可能还写一些文档，但是到了项目紧急的时候能把代码写完就不错了，文档的事情就等不忙的时候再慢慢写，然后这个慢慢写的过程基本也是不具有操作性的；而且就算写了，文档和代码的同步工作又是一个让人无比头疼的事情。话说回来，我们每次写代码都会写注释，有什么是比代码注释更好的文档呢。Sphinx是一个自动化生成Python文档的工具，其可以提取Python代码中的文档注释自动生成文档，方便我们快速生成帮助文件，包括Python的官方文档都是用该工具生成的，下面我就向大家介绍下Sphinx的基础使用方式用。 基础资料我将用如下代码生成文档run.py123456789101112131415161718class run(): ''' 用于测试的类 ''' def start(self): ''' 无参数 打印Hello Word :return: ''' print("Hello Word") def vae(self, info:str): """ 有参数 打印参数内容 :param info: :return: """ print(info) stop.py123456789101112131415161718class stop(): ''' 用于测试的类 ''' def end(self): ''' 无参数 打印Hello Word :return: ''' print("Hello Word") def vae(self, info:str): """ 有参数 打印参数内容 :param info: :return: """ print(info) 安装当前目录为demo，包含run.py和stop.py两个文件。1234➜ Demo tree -L 2 ././├── run.py├── stop.py 创建虚拟环境并进入12➜ Demo virtualenv venv➜ Demo source venv/bin/activate 安装 Sphinx1(venv) ➜ Demo pip install sphinx 使用Sphinx提供默认的快速配置方案，通过命令行交互即可完成全部的配置我的配置方案如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869(venv) ➜ Demo sphinx-quickstartWelcome to the Sphinx 1.8.1 quickstart utility.Please enter values for the following settings (just press Enter toaccept a default value, if one is given in brackets). Selected root path: .You have two options for placing the build directory for Sphinx output.Either, you use a directory "_build" within the root path, or you separate"source" and "build" directories within the root path.&gt; Separate source and build directories (y/n) [n]: yInside the root directory, two more directories will be created; "_templates"for custom HTML templates and "_static" for custom stylesheets and other staticfiles. You can enter another prefix (such as ".") to replace the underscore.&gt; Name prefix for templates and static dir [_]:The project name will occur in several places in the built documentation.&gt; Project name: Demo&gt; Author name(s): vae&gt; Project release []: 1.0.0If the documents are to be written in a language other than English,you can select a language here by its language code. Sphinx will thentranslate text that it generates into that language.For a list of supported codes, seehttp://sphinx-doc.org/config.html#confval-language.&gt; Project language [en]: zh_cnThe file name suffix for source files. Commonly, this is either ".txt"or ".rst". Only files with this suffix are considered documents.&gt; Source file suffix [.rst]:One document is special in that it is considered the top node of the"contents tree", that is, it is the root of the hierarchical structureof the documents. Normally, this is "index", but if your "index"document is a custom template, you can also set this to another filename.&gt; Name of your master document (without suffix) [index]:Indicate which of the following Sphinx extensions should be enabled:&gt; autodoc: automatically insert docstrings from modules (y/n) [n]: y&gt; doctest: automatically test code snippets in doctest blocks (y/n) [n]: y&gt; intersphinx: link between Sphinx documentation of different projects (y/n) [n]: y&gt; todo: write "todo" entries that can be shown or hidden on build (y/n) [n]: y&gt; coverage: checks for documentation coverage (y/n) [n]: y&gt; imgmath: include math, rendered as PNG or SVG images (y/n) [n]: y&gt; mathjax: include math, rendered in the browser by MathJax (y/n) [n]: y&gt; ifconfig: conditional inclusion of content based on config values (y/n) [n]: y&gt; viewcode: include links to the source code of documented Python objects (y/n) [n]: y&gt; githubpages: create .nojekyll file to publish the document on GitHub pages (y/n) [n]: yNote: imgmath and mathjax cannot be enabled at the same time. imgmath has been deselected.A Makefile and a Windows command file can be generated for you so that youonly have to run e.g. `make html' instead of invoking sphinx-builddirectly.&gt; Create Makefile? (y/n) [y]:&gt; Create Windows command file? (y/n) [y]: nCreating file ./source/conf.py.Creating file ./source/index.rst.Creating file ./Makefile.Finished: An initial directory structure has been created.You should now populate your master file ./source/index.rst and create other documentationsource files. Use the Makefile to build the docs, like so: make builderwhere "builder" is one of the supported builders, e.g. html, latex or linkcheck. 配置完后，会形成如下目录结构123456789101112131415161718venv) ➜ Demo tree -L 2.├── Makefile├── build├── run.py├── source│ ├── _static│ ├── _templates│ ├── conf.py│ └── index.rst├── stop.py└── venv ├── bin ├── include ├── lib └── pip-selfcheck.json8 directories, 6 files 修改source/conf.py，增加如下内容（或者修改该文件的 15~17行）123import osimport syssys.path.insert(0, os.path.abspath('../')) 该配置规定了源文件的路径，我的Sphinx配置在所有源文件的第二层，所以源文件的路径是../。 执行生成api文档的操作1234(venv) ➜ Demo sphinx-apidoc -o source ./File source/run.rst already exists, skipping.File source/stop.rst already exists, skipping.File source/modules.rst already exists, skipping. 其中-o参数为输出的文档配置的路径，这个需要和Sphinx的配置文件路径路径保持一致；最后一个参数为源文件的根目录。 执行make html生成文档1234567891011121314151617181920212223242526(venv) ➜ Demo make html 正在运行的是 Sphinx v1.8.1正在加载翻译 [zh_cn]... 完成创建输出目录…loading intersphinx inventory from https://docs.python.org/objects.inv...intersphinx inventory has moved: https://docs.python.org/objects.inv -&gt; https://docs.python.org/3/objects.inv构建 [mo]：0 个 po 文件的目标文件已过期构建 [html]: 4 个源文件的目标文件已过期updating environment: 4 added, 0 changed, 0 removedreading sources... [100%] stop查找当前已过期的文件……没有找到Pickle 序列化环境……完成检查一致性……/Users/vae/work/build/Python/Demo/source/modules.rst: WARNING: document isn&apos;t included in any toctree完成准备文档……完成写入输出……[ 25%] index 写入输出……[ 50%] modules 写入输出……[ 75%] run 写入输出……[100%] stop生成索引…… genindex py-modindexhighlighting module code... [100%] stop写入附加页面…… search复制静态文件……done复制额外文件……完成导出 Chinese (code: zh) 的搜索索引……完成导出对象清单……完成build 成功, 1 warning.HTML 页面保存在 build/html 目录。 通过浏览器打开 build/html/index.html既为我们的文档界面。 浏览默认的文档不是那么美观。我们改用sphinx_rtd_theme主题1(venv) ➜ Demo pip install sphinx_rtd_theme 修改source/conf.py中的html_theme = &#39;alabaster&#39;为html_theme = &#39;sphinx_rtd_theme&#39; 重新执行make html，生成新的配置文件。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Sphinx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WSL Ubuntu配置SecureCRT远程登录]]></title>
    <url>%2F2017%2F10%2F30%2FWSL%20Ubuntu%E9%85%8D%E7%BD%AESecureCRT%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%2F</url>
    <content type="text"><![CDATA[在Win10中安装WSL的Ubuntu系统，并通过SecureCRT来远程登录该系统。 正文部分]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>WSL</tag>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo搭建个人博客]]></title>
    <url>%2F2017%2F10%2F30%2F%E5%88%A9%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[记录通过Hexo搭建个人博客系统的全过程。其中主题选择NexT，部署平台为Github Pages 和 Coding.net，图床选用七牛云，写作软件选用Yu Writer。 前言我一直以来想搭建一个自己的博客，因为对PHP有那么一点点了解，所以先尝试了WordPress。但是搭建完之后，不知道为什么速度委实感人；在线编辑，打开速度太慢，离线编辑又没有好的双向同步工具，只好放弃；但最近发现Hexo来搭建博客也不错，首先满足我的离线编辑需求，其次我也非常喜欢MarkDown简洁的语法，并且利用Github或者Coding.net的Pages服务可以直接发布到网上，不占用我的云服务器资源，所以果断转向Hexo。 搭建Hexo安装Node.js和npmHexo是基于Node.js的，相关的环境已经可以用npm来进行管理，所以我们只需要安装好Node.js和npm就可以自动安装Hexo了，另外在安装的过程中需要用到Git，所以Git也需要一并安装。我用的是MacBook Pro，直接通过brew安装Node.js和npm。1$ brew install node npm git 如果是Ubuntu，则可以通过apt安装1$ sudo apt install node npm git 如果是Windows 10，我建议使用WSL，安装Ubuntu来进行管理。 安装Hexo安装Hexo环境这里利用全局安装的方法安装Hexo，所以需要用到root权限。1$ sudo npm install hexo-cli -g 创建默认的博客环境选取一个文件夹作为博客服务的默认文件夹，然后执行如下命令,123$ mkdir blog$ cd blog$ hexo init 这里我新建了一个blog文件夹作为我的博客的默认路径，安装完后 会生成如下文件12345678910111213.├── _config.yml├── db.json├── node_modules├── package.json├── scaffolds│ ├── draft.md│ ├── page.md│ └── post.md├── source│ └── _posts└── themes └── landscape 开启博客服务123$ hexo serverINFO Start processingINFO Hexo is running at http://localhost:4000 . Press Ctrl+C to stop. 至此我们的博客服务就开启了，通过浏览器打开http://localhost:4000这个地址 就可以访问我们的博客了。另外参数server可以简写为s，访问端口可以通过-p参数指定，如想通过8080端口访问网页，上述命令可以简写为123$ hexo s -p 8080INFO Start processingINFO Hexo is running at http://localhost:8080 . Press Ctrl+C to stop. 创建一个新的页面1$ hexo new "Hello Vae" 执行上述命令后，会在source/_posts文件夹下创建一个名为Hello Vae.md的文件，这个文件就是我们新的页面文件。 配置NexT主题安装NexT主题原始的Hexo 主题不太适合做个人的博客（主要是没人做图），所以选择了NexT这个简洁大方的且易于配置的主题。还是在blog的根目录执行如下命令，等待安装完成。1$ git clone https://github.com/iissnan/hexo-theme-next themes/next 安装完成后，在themes文件加下，会出现next文件夹，这个就是存储我们NexT主题相关文件。编辑blog录中的_config.yml配置文件， 找到 theme 字段，并将其值更改为 next，如此来开启Next主题。 配置Mist SchemeNexT主题提供三种不一样的风格可供选择，我的博客选择的是Mist。修改方法如下编辑next目录中的_config.yml配置文件，搜索 scheme 关键字。 你会看到有三行 scheme 的配置，将你需用启用的 scheme 前面注释 # 去除即可。123#scheme: Muse scheme: Mist #scheme: Pisces 其余的配置可参照NexT官方帮助文档。 启用畅言评论系统NexT主题原生支持畅言的评论系统。只需要开启相关的服务即可。编辑next目录中的_config.yml配置文件，启用畅言评论系统。畅言的appid和appkey,可以从畅言后台的左侧菜单”后台总览”获取.12345# changyanchangyan:enable: trueappid: *******appkey: ********** 以后在每篇博客的注释部分 comments: true即可开启评论功能，如：12345678910---title: Hexo搭建个人博客date: 2018-10-30 09:33:35comments: truecategories:- Hexotags:- Hexo- NexT--- 配置本地搜索既然是博客系统，那就避免不了搜索自己之前写的文档，自己的个人博客，文章数量不会太多，配置本地搜索即可满足需求。 安装 hexo-generator-searchdb，在站点的根目录下执行以下命令 1$ npm install hexo-generator-searchdb --save 编辑blog录中的_config.yml配置文件，新增以下内容到任意位置： 12345search: path: search.xml field: post format: html limit: 10000 编辑next目录中的_config.yml配置文件，启用本地搜索功能： 123# Local search local_search: enable: true 发布到GitHub Github Pages 是面向用户、组织和项目开放的公共静态页面搭建托管服务，站点可以被免费托管在 Github 上，你可以选择使用Github Pages默认提供的域名github.io或者自定义域名来发布站点。Github Pages支持自动利用 Hexo 生成站点，也同样支持纯 HTML 文档，将你的Hexo站点托管在Github Pages上是一个不错的选择。 创建仓库新建一个名为你的用户名.github.io的仓库，比如说，如果你的github用户名是test，那么你就新建test.github.io的仓库（必须是你的用户名，其它名称无效），将来你的网站访问地址就是 http://test.github.io 了，是不是很方便？由此可见，每一个github账户最多只能创建一个这样可以直接使用域名访问的仓库。几个注意的地方： 注册的邮箱一定要验证，否则不会成功； 仓库名字必须是：username.github.io，其中username是你的用户名；创建成功后，以后你的博客所有代码都是放在这个仓库里啦。 创建SSH Key输入命令ssh-keygen -t rsa –C “youremail@example.com”。此处的邮箱地址，填写你注册的邮箱地址。在回车中会提示你输入一个密码，这个密码会在你提交项目时使用，如果为空的话提交项目时则不用输入。 配置发布内容编辑blog录中的_config.yml配置文件，搜索 scheme 关键字，修改成以下内容：1234deploy: type: git repo: github: https://github.com/vae-0118/vae-0118.github.io.git,master 发布到GitHub Pages配置完成后，运行如下执行，即可将博客发布到GitHub Pages上：123$ hexo clean$ hexo generate$ hexo deploy 上述命令的后两条还可简化为1$ hexo g -d 发布到Coding.net设置七牛云图床利用Yu Writer写博客]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F10%2F28%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Normal</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qt5 中文乱码]]></title>
    <url>%2F2017%2F10%2F06%2FQt5%20%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%2F</url>
    <content type="text"><![CDATA[qt5.8 中文乱码解决方法：pragma execution_character_set(“utf-8”)]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Docker容器中进行Flask应用的开发]]></title>
    <url>%2F2017%2F10%2F03%2F%E5%9C%A8Docker%E5%AE%B9%E5%99%A8%E4%B8%AD%E8%BF%9B%E8%A1%8CFlask%E5%BA%94%E7%94%A8%E7%9A%84%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[Docker技术越来越得到广泛的应用。利用Docker可以创建一个隔离的、自包含的程序运行环境，并且非常方便的进行部署。这篇文章将详细介绍，如何在Docker中开发Flask应用以及如何在Docker中来运行、访问Flask应用。 Docker的优势通常对于Python开发来讲，我们可以借助virtualenv来建立彼此独立的开发环境。比如应用程序A依赖Python2.7，而应用程序B依赖Python3.5。我们可以分别建立两个virtualenv，其中一个安装python2.7，另外一个安装python3.5。之后我们就可以在各自的虚拟环境中进行开发了。貌似，viertualenv完美解决了不同程序的环境依赖问题。可是，真的是这样吗？ 想象一下，我们在开发环境搭建了一套virtualenv，如果部署到生产环境中，还需要再生产环境再部署一套完全一样的virtualenv，对不对？而且还需要在主机上安装必要的软件才能建立虚拟环境。 利用Docker就可以解决这个问题。Docker不但可以做到在同一台主机上开发时建立不同的环境，还可以将建立的Docker镜像搬到其他不同的主机上，而不需要再次安装环境就可以运行程序。这样就可以保证开发、测试、生产环境的服务器上的环境完全一致。 本篇文章默认已经在你的服务器上安装好了Docker服务。如不会安装请参考Docker的官方文档。本文重点是讲解如何构建Docker镜像、如何在镜像中开发Flask程序、如何在镜像中运行Flask应用。 创建Docker镜像搭建Flask应用的框架先创建一个Flask应用程序的目录，我们叫它toolbox_docker。123$ cd ~$ mkdir -p toolbox_docker$ cd toolbox_docker 在这个目录中，我们将创建Flask应用程序的源码文件夹toolbox、用于构建Docker镜像的Dockerfile以及Flask应用说明文件Readme.md。 .├── Dockerfile├── Readme.md└── toolbox Flask 应用程序源码toolbox目录结构如下： ├── app├── manage.py├── requirements.txt└── start_server.sh 在这个程序的源码中，包含Flask应用的管理脚本、项目的依赖requirements.txt、以及Flask应用的启动脚本start_server.sh。 创建entry-point启动脚本entry-point启动脚本是用来启动Flask应用程序的。这个脚本可以作为容器启动时的默认命令，这样在容器启动时，Flask应用程序就被启动了。start_server.sh脚本如下：12345678910111213141516#!/bin/bashset -etouch /opt/toolbox/log/gunicorn.logtouch /opt/toolbox/log/gunicorn.errtouch /opt/toolbox/log/access.log # Start Gunicorn processesecho Starting Gunicorn...exec gunicorn manage:app \ --bind 0.0.0.0:8000 \ --workers 4 \ --log-level=info \ --log-file=/opt/toolbox/log/gunicorn.log \ --access-logfile=/opt/toolbox/log/access.log \ &quot;$@&quot;echo Gunicorn is running... 在这个脚本中，我们创建了三个log files用于记录gunicorn的运行情况。并且通过gunicorn启动Flask应用。最后，”$@”允许我们在容器启动时，再传递额外的参数给gunicorn。另外，要记得修改start_server.sh的执行权限：$ chmod u+x start_server.sh 创建Dockerfile创建Docker镜像的构建文件Dockerfile。内容如下：12345678910111213141516171819202122232425262728293031323334353637383940########################################################## # Dockerfile to run a flask-based web application# Based on an centos:7 image ########################################################### Set the base image to use to centos FROM centos:7# Set the file maintainer MAINTAINER liuchunming033,liuchunming033@163.com# Set env varibles used in this Dockerfile (add a unique prefix, such as DOCKYARD) # Local directory with project source ENV DOCKYARD_SRC=toolbox # Directory in [Container](http://lib.csdn.net/base/docker &quot;Docker知识库&quot;) for all project files ENV DOCKYARD_SRCHOME=/opt # Directory in container for project source files ENV DOCKYARD_SRCPROJ=/opt/toolbox# Update the defualt application repository source list RUN yum -y install epel-release RUN yum -y install python-pip RUN yum clean all# Copy application source code to SRCDIR COPY $DOCKYARD_SRC $DOCKYARD_SRCPROJ# Create application subdirectories WORKDIR $DOCKYARD_SRCPROJ RUN mkdir log VOLUME [“$DOCKYARD_SRCPROJ/log/”]# Install Python dependencies RUN pip install -r $DOCKYARD_SRCPROJ/requirements.txt# Port to expose EXPOSE 8000# Copy entrypoint script into the image WORKDIR $DOCKYARD_SRCPROJ ENTRYPOINT [“./start_server.sh”] Dockerfile表明了我们构建Docker镜像的步骤。1、我们将centos:7作为基础镜像，后续的指令都是在此基础镜像中安装的；2、使用ENV指令在Container中设置环境变量。这些环境变量可以在Dockerfile的后面指令中使用，也可以被在该容器中运行的程序使用。3、执行YUM安装系统工具pip，pip用于安装后续requirements.txt中的依赖包4、将Docker主机上的目录DOCKYARD_SRC内容，复制到镜像中的DOCKYARD_SRCPROJ目录。5、使用requirements.txt来安装Python依赖。6、使用EXPOSE指令暴露8000端口，以便容器外可以访问8000端口7、ENTRYPOINT指令规定了在容器启动时执行的指令。这里是启动Flask应用的脚本。 构建Docker镜像$ docker build -t automation/toolbox ~/toolbox_docker将构建的Docker镜像命名为automation/toolbox。该构建执行过程中将经过一系列的Step。最终将输出类似Successfully built 08de9083be30的信息。表示构建镜像已经完成。构建完成后，执行docker images命名查看构建后的镜像： 12REPOSITORY TAG IMAGE ID CREATED SIZE automation/toolbox latest 08de9083be30 3 days ago 360.7 MB 启动Docker容器执行docker run命令启动构建的镜像：sudo docker run –rm -d -p 8002:8000 -v /var/log/toolbox:/opt/toolbox/log –name toolbox_server –restart=always automation/toolbox上面这个命令的解释如下：1、 –rm 表示每次启动容器时，删除旧的容器2、-d 表示后台启动容器3、-p 8002:8000 表示将Docker主机的8002端口与容器的8000接口绑定，这样访问Docker主机的8002端口时就相当于访问了容器内的8000端口。而容器内的8000端口正好是Flask应用提供的端口。4、-v 表示将Docker主机的/var/log/toolbox目录与容器内的/opt/toolbox/log目录做映射。这样Flask应用在容器内产生的log文件就可以在主机的/var/log/toolbox目录里面直接读取了。5、–name 选项给启动的容器起了一个名字6、–restart=always表示当容器中的Flask应用停止或者崩溃时，要重新启动Docker容器6、automation/toolbox是镜像的名字。 查看Docker容器执行docker ps命令查看docer容器:12CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES ce272d8960b4 automation/toolbox “/start_server.sh” 3 days ago Up 3 days 0.0.0.0:8002-&gt;8000/tcp toolbox_server1 管理Docker容器下面的命令用于启动、停止、重启Docker容器：123$ docker stop toolbox_server1 $ docker start toolbox_server1 $ docker restart toolbox_server1 修改Gunicorn启动选项Docker允许在容器启动时传递参数给容器中执行的命令，在本文中Docker容器启动时，执行的是start_server.sh。start_server.sh脚本中执行的是Gnicorn，因此传递参数给start_server.sh时，就相当于传递参数给Gnicorn了。比如要修改Gnicorn启动的线程数，可以这么做：docker run automation/toolbox --workers 5]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Python</tag>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flask SQLAlchemy 脚本测试方法]]></title>
    <url>%2F2017%2F09%2F22%2FFlask%20SQLAlchemy%20%E8%84%9A%E6%9C%AC%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[app / db上下文 环境中测试脚本123456789from flask import Flaskfrom flask_sqlalchemy import SQLAlchemyapp = Flask(__name__)with app.app_context(): app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = True app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///~/work/TowerMonitor/TMService/db/global.db' db = SQLAlchemy(app) if __name__ == '__main__':]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qt创建应用程序图标]]></title>
    <url>%2F2017%2F09%2F06%2FQt%E5%88%9B%E5%BB%BA%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%9B%BE%E6%A0%87%2F</url>
    <content type="text"><![CDATA[方法一：1.制作一个心仪的图标app.ico(制作工具) 2.拷贝到源代码目录中 3.在*.project文件中添加一行： RC_ICONS = app.ico 方法二：1.制作一个心仪的图标app.ico(制作工具) 2.拷贝到源代码目录中 3.在项目的目录中新建文本文档，并且重命名为：proj.rc 4.打开proj.rc文档，编辑如下内容： IDI_ICON1 ICON DISCARDABLE “app.ico” 5.在*.project文件中添加如下一行： RC_FILE = proj.rc]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker 学习]]></title>
    <url>%2F2017%2F08%2F17%2FDocker%20%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[安装好Docker 并且能运行 Docker HelloWorld 后 运行一个容器sudo docker run -i -t ubuntu /bin/bash -i 保证容器 STDIN 开启 -t 告诉 Docker 为要创建的容器分配一个伪 tty 终端 这样新创建的容器才能提供一个交互式Shell 容器创建完毕后就会执行容器中的 /bin/bash 命令启动一个Bash shell 使用第一个容器 在容器中执行命令apt-get updateapt-get install vim 更新 Ubuntu , 安装 vim 退出容器exit 退出当前容器 查看容器sudo docker ps -a 查看当前系统中容器的列表sudo docker ps 查看当前系统正在运行的容器 最后一列可以看到 容器名称 容器命名sudo docker run -name ubuntu-test -i -t ubuntu /bin/bash创建一个 名为 ubuntu-test 的容器 删除容器sudo docker rm &quot;容器名称或者 ID&quot; 启动停止的容器sudo docker start ubuntu-test 连接正在运行的 容器sudo docker attach ubuntu-test 按回车进入回话 创建一个守护式容器sudo docker run --name daemon_dave -d ubuntu /bin/sh -c &quot;while true; do echo hello world ; sleep 1; done&quot; 命令创建了一个名为 daemon_dave 的容器 -d 参数 会将容器放到后台运行 该命令一直打印 hello world ,知道容器或其进程停止运行 获取容器日志sudo docker logs daemon_dave 输出最后几条日志项并返回sudo docker logs -f daemon_dave 跟踪日志,通过 ctrl + c 退出sudo docker logs -ft daemon_dave 加上时间戳 查看容器内部进程sudo docker top daemon_dave 查看容器内部所有进程 在容器内部运行进程sudo docker exec -t -i daemon_dave /bin/bash在容器内创建一个新的 bash 会话 停止守护式容器sudo docker stop daemon_dave 1234567891011121314151617181920212223242526docker run -i -t ubuntu /bin/bash #-i保证容器stdin开启，-t为容器分配一个伪tty终端。这样容器才能提供一个交互式shellhostname #查看容器的主机名cat /etc/hosts #查看hosts文件ps -aux #查看容器中的进程apt-get update &amp; apt-get install vim #一样可以在容器里安装程序exit #退出容器docker ps #查看运行中的docker容器，-l 最后一次运行的容器docker run -i -t --name=容器名称 ubuntu /bin/bash #默认随机名称，--name起名docker start 容器名称或者容器IDdocker attach 容器名称或者容器ID #附着到正在运行的容器上docker run --name=容器名称 -d ubuntu /bin/sh -c &quot;while true;do echo hello;sleep 1;done&quot; #创建可以长期运行的守护式容器docker logs 容器名称 #获取容器日志 -f 可以获取到最后几行，-t 可以显示时间戳docker top 容器名称 #查看容器内部的进程docker exec -d 容器名称 touch /etc/new_config_file #在容器内执行命令docker exec -t -i 容器名称 /bin/bash #打开容器的shelldocker stop 容器名称 #停止一个容器docker run --restart =always --name 容器名称 -d ubuntu /bin/bash -c &quot;while true;do echo hello;sleep 1;done&quot; #创建一个能够自动重启的容器，always 可以替换为on-failure，可以指定次数如：on-failure:5docker inspect 容器名称或者ID #获取更多的容器信息docker inspect --format=&apos;&#123;&#123;.State.Running&#125;&#125;&apos; 容器名称 #选定查看结果docker rm 容器名称或者ID #删除一个容器docker ps -a #列出所有容器docker ps -a -q #列出所有的docker rm `ps -a -q` #删除所有的容器]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu 16.04 安装 Docker]]></title>
    <url>%2F2017%2F08%2F16%2FUbuntu%2016.04%20%E5%AE%89%E8%A3%85%20Docker%2F</url>
    <content type="text"><![CDATA[Docker 分为2个版本 EE and CE 企业版 和 社区版 Docker CE安装软件包以允许通过HTTPS使用存储库：12345$ sudo apt-get install \ apt-transport-https \ ca-certificates \ curl \ software-properties-common 添加Docker的官方GPG密钥：1$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - 使用以下命令设置稳定版本库:1$ sudo add-apt-repository \ "deb [arch=amd64] &lt;DOCKER-EE-URL&gt; \ $(lsb_release -cs) \ stable-17.03" 更新apt包索引。1$ sudo apt-get update 安装最新版本的Docker:1$ sudo apt-get install docker-ce 要升级Docker，首先运行sudo apt-get update，然后按照安装说明，选择要安装的新版本。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[转载：python web 部署：nginx + gunicorn + supervisor + flask 部署笔记]]></title>
    <url>%2F2017%2F08%2F06%2Fpython%20web%20%E9%83%A8%E7%BD%B2%EF%BC%9Anginx%2Bgunicorn%2Bsupervisor%2Bflask%E9%83%A8%E7%BD%B2%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[python web 部署转自:http://www.jianshu.com/p/be9dd421fb8d web开发中，各种语言争奇斗艳，web的部署方面，却没有太多的方式。简单而已，大概都是 nginx 做前端代理，中间 webservice 调用程序脚本。大概方式：nginx + webservice + script nginx 不用多说，一个高性能的web服务器。通常用来在前端做反向代理服务器。所谓正向与反向（reverse），只是英文说法翻译。代理服务，简而言之，一个请求经过代理服务器从局域网发出，然后到达互联网上服务器，这个过程的代理为正向代理。如果一个请求，从互联网过来，先进入代理服务器，再由代理服务器转发给局域网的目标服务器，这个时候，代理服务器为反向代理（相对正向而言）。 正向代理：{ 客户端 —》 代理服务器 } —》 服务器反向代理：客户端 —》 { 代理服务器 —》 服务器 }{} 表示局域网 nginx既可以做正向，也可以做反向。webservice 的方式同样也有很多方式。常见的有FastCGI，WSGI等。我们采用gunicorn为 wsgi容器。python为服务器script，采用flask框架。同时采用supervisor管理服务器进程。也就是最终的部署方式为：nginx + gunicorn + flask ++ supervisor 创建一个项目1mkdir myproject 创建 python 虚拟环境virtualenv 可以说是 python 的一个大杀器。用来在一个系统中创建不同的 python 隔离环境。相互之间还不会影响，使用简单到令人发指。（我的工作路径是/home/rsj217/rsj217）123mkdir myprojectcd myprojectvirtualenv venv 创建了 venv 环境之后，激活就可以了1source venv/bin/activate 安装 python web 框架 —flaskflask 是一个 python web micro framework。简洁高效，使用也很简单。flask 依赖两个库werkzeug 和jinjia2。采用 pip 方式安装即可。1pip install flask 测试我们的 flask 安装是否成功，并使用 flask 写一个简单的 web 服务。vim myapp.py12345678from flask import Flaskapp = Flask(__name__)@app.route('/')def index(): return 'hello world'if __name__ == '__main__': app.debug = True app.run() 启动 flask1python myapp.py 此时，用浏览器访问 http://127.0.0.1:5000 就能看到网页显示 hello world。 使用 gunicorn 部署 python web现在我们使用 flask 自带的服务器，完成了 web 服务的启动。生产环境下，flask 自带的 服务器，无法满足性能要求。我们这里采用 gunicorn 做 wsgi容器，用来部署 python。 安装 gunicorn1pip install gunicorn pip 是一个重要的工具，python 用来管理包。还有一个最佳生产就是每次使用 pip 安装的库，都写入一个 requirement 文件里面，既能知道自己安装了什么库，也方便别人部署时，安装相应的库。1pip freeze &gt; requirements.txt 以后每次 pip 安装了新的库的时候，都需freeze 一次。 当我们安装好 gunicorn 之后，需要用 gunicorn 启动 flask，注意 flask 里面的name里面的代码启动了 app.run(),这个含义是用 flask 自带的服务器启动 app。这里我们使用了 gunicorn，myapp.py 就等同于一个库文件，被 gunicorn 调用。1gunicron -w4 -b0.0.0.0:8000 myapp:app 此时，我们需要用 8000 的端口进行访问，原先的5000并没有启用。其中 gunicorn 的部署中，，-w 表示开启多少个 worker，-b 表示 gunicorn 开发的访问地址。 想要结束 gunicorn 只需执行 pkill gunicorn，有时候还的 ps 找到 pid 进程号才能 kill。可是这对于一个开发来说，太过于繁琐，因此出现了另外一个神器—supervisor，一个专门用来管理进程的工具，还可以管理系统的工具进程。 安装 supervisor123pip install supervisorecho_supervisord_conf &gt; supervisor.conf # 生成 supervisor 默认配置文件vim supervisor.conf # 修改 supervisor 配置文件，添加 gunicorn 进程管理 在myapp supervisor.conf 配置文件底部添加 (注意我的工作路径是/home/rsj217/rsj217/)123456789[program:myapp]command=/home/rsj217/rsj217/myproject/venv/bin/gunicorn -w4 -b0.0.0.0:2170 myapp:app ; supervisor启动命令directory=/home/rsj217/rsj217/myproject ; 项目的文件夹路径startsecs=0 ; 启动时间stopwaitsecs=0 ; 终止等待时间autostart=false ; 是否自动启动autorestart=false ; 是否自动重启stdout_logfile=/home/rsj217/rsj217/myproject/log/gunicorn.log ; log 日志stderr_logfile=/home/rsj217/rsj217/myproject/log/gunicorn.err ; 错误日志 supervisor的基本使用命令12345supervisord -c supervisor.conf 通过配置文件启动supervisorsupervisorctl -c supervisor.conf status 察看supervisor的状态supervisorctl -c supervisor.conf reload 重新载入 配置文件supervisorctl -c supervisor.conf start [all]|[appname] 启动指定/所有 supervisor管理的程序进程supervisorctl -c supervisor.conf stop [all]|[appname] 关闭指定/所有 supervisor管理的程序进程 supervisor 还有一个web的管理界面，可以激活。更改下配置1234567891011[inet_http_server] ; inet (TCP) server disabled by defaultport=127.0.0.1:9001 ; (ip_address:port specifier, *:port for all iface)username=user ; (default is no username (open server))password=123 ; (default is no password (open server))[supervisorctl]serverurl=unix:///tmp/supervisor.sock ; use a unix:// URL for a unix socketserverurl=http://127.0.0.1:9001 ; use an http:// url to specify an inet socketusername=user ; should be same as http_username if setpassword=123 ; should be same as http_password if set;prompt=mysupervisor ; cmd line prompt (default &quot;supervisor&quot;);history_file=~/.sc_history ; use readline history if available 现在可以使用 supervsior 启动 gunicorn啦。运行命令 supervisord -c supervisor.conf 访问 http://127.0.0.1:9001 可以得到 supervisor的web管理界面，访问 http://127.0.0.1:2170 可以看见gunciron 启动的返回的 hello world 安装配置 nginx采用 apt-get方式安装最简单。运行 sudo apt-get install nginx。安装好的nginx的二进制文件放在/usr/sbin/文件夹下面。而nginx的配置文件放在 /etc/nginx下面。 使用 supervisor 来管理 nginx。这里需要注意一个问题，linux的权限问题。nginx是sudo的方式安装，启动的适合也是 root用户，那么我们现在也需要用 root用户启动supervisor。增加下面的配置文件12345678[program:nginx]command=/usr/sbin/nginxstartsecs=0stopwaitsecs=0autostart=falseautorestart=falsestdout_logfile=/home/rsj217/rsj217/myproject/log/nginx.logstderr_logfile=/home/rsj217/rsj217/myproject/log/nginx.err 到此为止，进步的 web 部属已经完成。当然，最终我们需要把项目代码部属到服务器上.批量的自动化部属需要另外一个神器 fabric.具体使用，就不再这篇笔记阐述。项目源码中包含了fabric文件。下载fabric，更改里面的用户名和秘密，就可以部属在自己或者远程的服务器上了。 项目源码： https://coding.net/u/rsj217/p/myproject/git]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flask-login 简单 Demo， 最简单的实现登录方法]]></title>
    <url>%2F2017%2F07%2F26%2FFlask-login%20%E7%AE%80%E5%8D%95%20Demo%EF%BC%8C%20%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%99%BB%E5%BD%95%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Flask-login 简单 Demo， 最简单的实现登录方法 当使用MethodView的时候,login_required 使用方法1234class XxxxView(MethodView): decorators = [login_required] # 相当于 @login_required 装饰圈 def get(self): 主文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859from flask_sqlalchemy import SQLAlchemyfrom flask import Flask, redirect, url_for, requestfrom flask_login import LoginManager, current_user, login_user, login_required app = Flask(__name__)app.secret_key = 'Sqsdsffqrhgh.,/1#$%^&amp;'app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///./db/blog.db'app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = Trueapp.debug = True db = SQLAlchemy(app)login_manager = LoginManager()login_manager.init_app(app) password = '123' #只要用户输入的密码是 123 就可以登录 @login_manager.user_loader #使用user_loader装饰器的回调函数非常重要，他将决定 user 对象是否在登录状态def user_loader(id): #这个id参数的值是在 login_user(user)中传入的 user 的 id 属性 from model.model import User user = User.query.filter_by(id=id).first() return user # 添加登录视图，如果是GET方法，返回一个简单的表单 @app.route('/login/', methods=['GET', 'POST'])def login(): from model.model import User if request.method == 'GET': return ''' &lt;form action="#" method="POST"&gt; &lt;span&gt;请输入账号&lt;/span&gt; &lt;input type="text" name="name" id="name" placeholder="name"&gt; &lt;span&gt;请输入密码&lt;/span&gt; &lt;input type="password" name="pw" id="pw" placeholder="password"&gt; &lt;input type="submit" name="submit"&gt; &lt;/form&gt; ''' name = request.form.get('name') if request.form.get('pw') == password: user = User.query.filter_by(name=name).first() if not user: user = User(name=name) db.session.add(user) db.session.commit() login_user(user) return redirect(url_for('index')) return 'Bad login' #如果密码是 123 就会跳转到视图函数 index 上 @app.route('/index/')@login_requireddef index(): user = current_user return 'HelloWorld' if __name__ == '__main__': app.run() model.py1234567891011121314151617from model import * '''创建类的时候继承UserMixin ,有一些用户相关属性* is_authenticated ：是否被验证* is_active ： 是否被激活* is_anonymous : 是否是匿名用户* get_id() : 获得用户的id，并转换为 Unicode 类型''' class User(db.Model,UserMixin): __tablename__ = 'login_users' id = db.Column(db.Integer,primary_key=True) name = db.Column(db.String(50),unique=True) login_count = db.Column(db.Integer,default=0) last_login_ip = db.Column(db.String(128),default='unknown') 稍微全面一点的12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970from flask_sqlalchemy import SQLAlchemyfrom flask import Flask, redirect, url_for, request, flash, render_templatefrom flask_login import LoginManager, login_user, login_required, logout_user app = Flask(__name__)app.secret_key = 'Sqsdsffqrhgh.,/1#$%^&amp;'app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///./db/blog.db'app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = Trueapp.debug = True db = SQLAlchemy(app)login_manager = LoginManager()login_manager.init_app(app) login_manager.login_view = "login" # 定义登录的 视图login_manager.login_message = '请登录以访问此页面' # 定义需要登录访问页面的提示消息 @login_manager.user_loader # 使用user_loader装饰器的回调函数非常重要，他将决定 user 对象是否在登录状态def user_loader(id): # 这个id参数的值是在 login_user(user)中传入的 user 的 id 属性 from model.model import User user = User.query.filter_by(id=id).first() return user # 添加登录视图，如果是GET方法，返回一个简单的表单 @app.route('/login/', method=['GET', 'POST'])def login(): from model.model import User if request.method == 'POST': name = request.form.get('name') user = User.query.filter_by(name=name).first() if not user: flash('该用户不存在') elif request.form.get('pwd') != user.pwd: flash('密码错误') else: login_user(user, remember=True) next_url = request.args.get('next') return redirect(next_url or url_for('login_success')) return render_template('login.html') # 如果密码是 123 就会跳转到视图函数 index 上 @app.route('/')@login_requireddef index(): return 'Hello Tank' @app.route('/succees/')@login_requireddef login_success(): return render_template('base.html') @app.route('/logout/')@login_requireddef logout(): logout_user() # 登出用户 return '已经退出登录' @app.errorhandler(404)def page_not_found(error): return render_template('page_not_found.html'), 404 if __name__ == '__main__': app.run()]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flask文件上传]]></title>
    <url>%2F2017%2F07%2F22%2FFlask%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%2F</url>
    <content type="text"><![CDATA[form 加上属性 enctype = “multipart/form-data 后台能从前台 request 到 files集合获取上传的文件]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2017%2F07%2F02%2Fpython%20enumerate%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[enumerate()说明 enumerate()是python的内置函数 enumerate在字典上是枚举、列举的意思 对于一个可迭代的（iterable）/可遍历的对象（如列表、字符串），enumerate将其组成一个索引序列，利用它可以同时获得索引和值 enumerate多用于在for循环中得到计数 例如对于一个seq，得到： 1(0, seq[0]), (1, seq[1]), (2, seq[2]) enumerate()返回的是一个enumerate对象，例如： enumerate()使用 如果对一个列表，既要遍历索引又要遍历元素时，首先可以这样写： 123list1 = ["这", "是", "一个", "测试"]for i in range (len(list1)): print i ,list1[i] 上述方法有些累赘，利用enumerate()会更加直接和优美： 12345678list1 = ["这", "是", "一个", "测试"]for index, item in enumerate(list1): print index, item&gt;&gt;&gt;0 这1 是2 一个3 测试 enumerate还可以接收第二个参数，用于指定索引起始值，如： 12345678list1 = ["这", "是", "一个", "测试"]for index, item in enumerate(list1, 1): print index, item&gt;&gt;&gt;1 这2 是3 一个4 测试 补充如果要统计文件的行数，可以这样写：1count = len(open(filepath, 'r').readlines()) 这种方法简单，但是可能比较慢，当文件比较大时甚至不能工作。可以利用enumerate()：123count = -1 for index, line in enumerate(open(filepath,'r'))： count += 1]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flask-WTF 示例]]></title>
    <url>%2F2017%2F02%2F23%2FFlask-WTF%20%E7%A4%BA%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[from.py12345678910from flask_wtf import FlaskFormfrom wtforms import StringField, PasswordFieldfrom wtforms.validators import DataRequired, Length, Email, EqualTo class UserRegisterForm(FlaskForm): username = StringField('用户名', [DataRequired('用户名必填！'), Length(min=6, max=20, message='用户名必须介于6-20字符！')]) password = PasswordField('密码', [DataRequired('密码必填！'), Length(min=6, max=20, message='密码必须介于6-20字符！')]) confirm = PasswordField('重复密码', [DataRequired('重复密码必填！'), EqualTo('password', message='两次密码输入不一致！')]) email = StringField('邮箱', [DataRequired('邮箱必填！'), Email('邮箱格式不正确！')]) view.py12345678910111213141516171819202122class RegView(MethodView): def get(self): form = UserRegisterForm(request.form) return render_template('register.html', form=form) def post(self): form = UserRegisterForm(request.form) if User.query.filter_by(username=form.username.data).first(): flash("当前用户名已经注册！") return render_template('register.html', form=form) elif User.query.filter_by(email=form.email.data).first(): flash("当前邮箱已经注册！") return render_template('register.html', form=form) else: form.validate_on_submit() user = User( form.username.data, form.password.data, form.email.data, ) user.save() return redirect(url_for('.login')) jinja2 宏方法 helper.html 获取 flask的 flash 消息1234567891011121314151617181920&#123;% macro renden_field(field) %&#125; &#123;% if field.errors %&#125; &#123;% for error in field.errors %&#125; &lt;li style="font-size: medium"&gt;&#123;&#123; error &#125;&#125;&lt;/li&gt; &#123;% endfor %&#125; &#123;% endif %&#125;&#123;% endmacro %&#125; &#123;% macro messages(get_flashed_messages) %&#125; &#123;% with messages = get_flashed_messages() %&#125; &#123;% if messages %&#125; &#123;% for message in messages %&#125; &lt;div class="alert alert-danger"&gt; &lt;a href="#" class="close" data-dismiss="alert"&gt;×&lt;/a&gt; &#123;&#123; message &#125;&#125; &lt;/div&gt; &#123;% endfor %&#125; &#123;% endif %&#125; &#123;% endwith %&#125;&#123;% endmacro %&#125; form.html12345678910111213141516171819&#123;% from 'helper.html' import renden_field,messages %&#125; &lt;form action="" class="form-horizontal" method="post"&gt; &#123;&#123; form.csrf_token &#125;&#125; &#123;&#123; messages(get_flashed_messages) &#125;&#125; &lt;div class="panel-body"&gt; &lt;div class="form-group"&gt; &#123;&#123; form.username.label(class="col-lg-2 col-sm-2 control-label") &#125;&#125; &lt;div class="col-md-6"&gt; &#123;&#123; form.username(class='from-control') &#125;&#125; &#123;&#123; renden_field(form.username) &#125;&#125; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &#123;&#123; form.password.label(class="col-lg-2 col-sm-2 control-label") &#125;&#125; &lt;div class="col-md-6"&gt; &#123;&#123; form.password(class='from-control') &#125;&#125; &#123;&#123; renden_field(form.password) &#125;&#125; &lt;/div&gt; &lt;/div&gt;]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Flask</tag>
      </tags>
  </entry>
</search>
